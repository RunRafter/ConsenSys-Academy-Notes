## Cryptographic Hash Functions

- A hash function is designed to take input data of any size and generate an output of fixed size (called a hash). This process is called hashing. Hashing makes it so that it cannot be reversed such that the original input is revealed. It should also be noted that the hashing function can be run many times against the same input and always create the same output. Slightly similar inputs should produce very different outputs.
- Hash functions are:
  1.  Fast - hashing 1 bit vs 1 GB should not take much more time
  2.  Deterministic - providing same input to hash fcn will always produce same output
  3.  Infeasible to reverse - cannot compute data that was input into hash function given the result (one-way function)
  4.  Small change in input results in very different output - apparent randomness
  5.  Collision resistant - infeasible to find 2 input with same output

### Applications of Hash Functions

- Verify data integrity (i.e. checksums - checking file hash against established hash proves data hasn't been tampered with, password hashing - using hashes to verify passwords - should store passwords in hashes)

  - Any permutation to the original data will produce an completely different output hash

- Proof of Work

  - Used as a mechanism for preventing service abuse by requiring requestor to put in computationally expensive work
  - Hard to find a given hash (hash within given threshold)
  - Easy to verify that work has been done (hash within that threshold)
  - Reduce spam, each transaction incurs a cost which makes it infeasible for spamming.

- Data Identification
  - Hash tables
  - P2P Data Sharing Networks - easy for user to determine identifier associated with any data: hash
  - Pseudorandom number - not truly random: deterministic and depend on input

### Resources
- [Blockchain Underpinnings: Hashing by ConsenSys Media](https://medium.com/@ConsenSys/blockchain-underpinnings-hashing-7f4746cbd66b "Blockchain Underpinnings: Hashing by ConsenSys Media")
- [Cryptographic hash functions on Wikipedia](https://simple.wikipedia.org/wiki/Cryptographic_hash_function "Cryptographic hash functions on Wikipedia")
- [Cryptographic hash functions by the Kahn Academy](https://simple.wikipedia.org/wiki/Cryptographic_hash_function "Cryptographic hash functions by the Kahn Academy")
- [Hashing Algorithms and Security - Computerphile](https://www.youtube.com/watch?v=b4b8ktEV4Bg "Hashing Algorithms and Security - Computerphile Video")

### Public Key Cryptography (aka. Assymmetric Cryptography)

- Key pairs are numbers that have unique complex mathemtical relationship
- Key pair is generated by entering random data into a Key Generation Algorithm, then a private key is outputed. A public key is derived from the private key. Many public keys can be derived from a single private key - in Ethereum, this is done with Eliptic Curve Cryptography. Random input data must also be kept secret, and be sufficiently random to prevent attackers from guessing input. The Key Generation Algorithm is deterministic - inputting same random data will generate the same private key. The same public keys can be derived from same private key.
- Public keys are shared while private keys are kept secret by the key owner.
- Public Key Cryptography are used for two things:
  - Encryption: Messages are encrypted with the public key, but only private key holder can decrypt a message encrypted with corresponding public key.
  - Authentication: A public key can verify ownership of corresponding private key. Authentication enables digital signatures to sign transactions on blockchain.
    - Example 1:
    We can send a secret message to someone and verify that only they (holder of some private key) can read it
    1. Sender encrypts message with recipient's public key
    2. Transmit encrypted message over publicly visible communication channels without fear of it being decrypted
    3. Once encrypted message reaches destination, recipient decrypts message using his private key.
    -Example 2 - Digital signatures (makes sure data has been verified by individual):

    1.  Alice (signer) has document that she wants to publicly sign eg. contract / legal document / transaction. Alice encrypts data with her private key, and appends it to original document, generating a signed document.
    2.  She can then publish the original document, the signed document, and the public key to a blockchain for anyone to verify she is the original owner of the document.
    3.  To verify Alice was the original owner, the verifier can decrypt the signed document with public key. Then decrypted signed document and original document generated by Alice should match. If document has been tampered with, decrypted data won't match original document, and verifier can reject signed document as invalid signature. 

    Digital signatures are an important feature of verifying blockchain txns on Bitcoin and Ethereum. Anyone with private key corresponding to an account can digitally sign a txn.

    ### References
    - [How are ethereum addresses generated?](https://ethereum.stackexchange.com/questions/3542/how-are-ethereum-addresses-generated "How are ethereum addresses generated?")

## Merkle Tree

- A merkle tree is a binary tree data structure that are derived from a set of data. Every leaf of the tree is a cryptographic hash of an item in the dataset. Every node is the hash of its two child elements.
- The benefit of this is that the entire tree is cryptographically authenticated, changing any leaf or node (any one piece of data) will fundamentally alter the root of the tree.
- Can use the root to efficiently verify every item at leaves of tree - allow Merkle Trees to act as succinct data proofs for large sets of data. Only a fraction/subset of data set is required to prove that data point is in fact in tree. 
- Computing membership of an item in Merkle Tree requires relatively few computations relative to size of data set. For a data set of size N, verification requires log(n) computations - making Merkle Trees scalable to extremely large datasets.
- In context of blockchains, Merkle Trees are used to succinctly store verification of a set of txns by including root hash of tree and block header.

## Patricia Tree 
- Particia Trees are space optimized radix trees, where each node has at least two children. They allow for storage of key/ value pairs where the keys are used to traverse the tree in order to find values stored at the leaves of the tree. This makes it easy to search, insert, or delete data and map large data sets.
- Ethereum uses data structure that combines Merkle and Patricia Trees to efficiently store and read large amounts of data.
- In the case of Ethereum Particia trees are used to store the balance of accounts where the keys are addresses and the values are account declarations which list the balance, nonce, code, and storage for each account.

### In-Depth

- A Merkle proof consists of a chunk, the root hash of the tree, and the "branch" consisting of all of the hashes going up along the path from the chunk to the root. Someone reading the proof can verify that the hashing, at least for that branch, is consistent going all the way up the tree, and therefore that the given chunk actually is at that position in the tree.

- The application is simple: suppose that there is a large database, and that the entire contents of the database are stored in a Merkle tree where the root of the Merkle tree is publicly known and trusted (eg. it was digitally signed by enough trusted parties, or there is a lot of proof of work on it). Then, a user who wants to do a key-value lookup on the database (eg. "tell me the object in position 85273") can ask for a Merkle proof, and upon receiving the proof verify that it is correct, and therefore that the value received actually is at position 85273 in the database with that particular root.

- It allows a mechanism for authenticating a small amount of data, like a hash, to be extended to also authenticate large databases of potentially unbounded size.

* If we want to verify a transaction we simply take the hash of that node as well as its adjacent node, this would be repeated until the root is reached. If the root hash is different from that which was derived, then the transaction has been tampered with. ![MerkleTree-Verification](/images//merkletree-verification.png)

- Bitcoin uses Merkle trees for "simplified payment verification": instead of downloading every transaction and every block, a "light client" can only download the chain of block headers, 80-byte chunks of data for each block that contain only five things: 
  - A hash of the previous header
  - A timestamp
  - A mining difficulty value
  - A proof of work nonce
  - A root hash for the Merkle tree containing the transactions for that block.
- If the light client wants to determine the status of a transaction, it can simply ask for a Merkle proof showing that a particular transaction is in one of the Merkle trees whose root is in a block header for the main chain.

- While they can prove the inclusion of transactions, they cannot prove anything about the current state (eg. digital asset holdings, name registrations, the status of financial contracts, etc). To get this information a light client would have to authenticate every single transaction in the chain.
  ![BitcoinMerkleTree](/images/bitcoinMerkleTree.jpg)

* Ethereum gets around this limitation by providing three tyoes if trees for three object types (Transactions, Receipts, State) which provides the light client with far more information.
  ![EthereumMerkleTree](/images/ethereumMerkleTree.png)

### Resources

[Ever Wonder How Merkle Trees Work?](https://media.consensys.net/ever-wonder-how-merkle-trees-work-c2f8b7100ed3)

[Partricia Tree - Ethereum Docs](https://github.com/ethereum/wiki/wiki/Patricia-Tree)

[Merkling in Ethereum](https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/)

## Blockchain Structure

- Blockchains accomplish several key features:

  - Maintain state in a peer to peer network
  - Coordinate state updates such that:
  - A majortity of participants agree the updates are legitimate
  - Consensus on the new system state is reached.

- Updates are broken into sets or blocks. These blocks are summarized by the Merkle tree root. Blocks are made in series of one another and reference previous blocks.

- A block includes:
  - A list of transactions, and a Merkle tree based on the list
- Hash of previous block
- Nonce which is used in POW, this value is incremented as a miner performs POW to find the block hash that matches the target block. Once the correct block hash is found the nonce is broadcasted across the network such that other miners can validate the winning miners POW.

### Resources

[Blockchain Demo](https://anders.com/blockchain/)

## Smart Contracts

- Smart Contracts should have the following characteristics

  1.  Trustless: No 3rd party or intermediaries should have exclusive access
  2.  Trackable: Transactions are traceable and easily audited
  3.  Irreversible: Transactions are final, security is priority.
  4.  Self-Executing: Reduces costs, and increases efficiency.

- Blockchains offer an ideal platform for Smart Contracts because a smart contract can live on a blockchain and achieve all of the goals listed above.

## Nodes

- Nodes are implemented in Peer to Peer Networks, they participate by running the corresponding software.

- Nodes are the gateway to the blockchain network, in the Ethereum network a users device that is Web3 Capable communicates with the Node over an RPC protocol, the node then connects to the blockchain network using a P2P protocol.

![P2P Network](/images/p2pnetwork.png)

- There are 3 ways in which a node can participate with the network.
  - Light Client: Contains a shallow copy of the blockchain
  - Full Node: Maintains a full copy of the blockchain, verify the correct block award has been distributed, ensures the correct data format is being maintained, checks that no double spending has occured, and validates that transactions have the correct signature.
  - Miners: Perform all of the same actions as Full Nodes but they also veirfy transactions through Proof-of-Work.

### In-Depth

- Light Client Protocols are designed for low-resource enviroments (i.e. Smartphones, Embedded Devices, etc) that cannot maintain a full node but need a high level of assurance regarding the current state. This is acccomplished by downloading bockheaders and verifying a small portion of the blockchain using a distributed hash table as a database for trie nodes.

- Partially light clients swap the database for GET requests such that no information is actually stored.

- Light clients utilize a Patricia Merkle Tree data structure where each node is the hash of its children, and each set of key/ value pairs map to a unique root hash. This is incredibly powerful because only the children of each node are needed to prove a root hashes validity.

- Merkle Trees are also highly scalable, even if the entire state tree is several gigabytes in size a light client would only need a few kilobytes of data to prove the state tree's validity.

- A Simplified Payment Verification proof of a node in a Partirica Tree consists of a complete subset of tree nodes that were processed in order to access it. "In a simple implementation of a Patricia tree, retrieving the value associated with a particular key requires descending the hash tree, constantly looking up nodes in the database by their hashes, until you eventually reach the final leaf node; a simple algorithm for producing an SPV proof is to simply run this naive algorithm, and record all of the database lookups that were made. SPV verification consists of running the naive lookup algorithm but pointing it to a custom database populated only with the nodes in the SPV proof; if there is a "node not found" error, then the proof is invalid."

- Light client protocols can be implemented to perform four different functions:
  - A light client wants to know the state of an account (nonce, balance, code or storage index) at a particular time. The light client can simply recursively download trie nodes from the state root until it gets to the desired value.
  - A light client wants to check that a transaction was confirmed. The light client can simply ask the network for the index and block number of that transaction, and recursively download transaction trie nodes to check for availability.
  - Light clients want to collectively validate a block. Each light client C[i] chooses one transaction index i with transaction T[i] (with corresponding receipt R[i]).
  - Light clients want to "watch" for events that are logged.

## Blockchain Forks

- A blockchain fork is when a block splits into two concurrent chains.
  - This can be either intentional such as the case when network nodes are performing software updates or unintentional in the case where miners produce are competing for Proof-of-Work verification.
    - In the case of unintentional forks caused by miners this is typically caused by two miners discovering the correct block hash at same time and broadcast it to the network simultaneously. The result is that other nodes may recieve notification from one of the miners quicker than the other resulting in two different histories and thus two different chains. As part of the protocol the longest chain is considered the "valid chain", at some point one of the chains will outgrow the other. As a general rule, users should wait for 6 block confirmations because it is almost guarenteed that the longest chain will be identified by that point.
  - Forks also occur when there is disagreement between communities in the same blockchain network. If one group implements new rules while another does not the group will split into two sepereate blockchains.
    - Hard Forks
      - This happens if the upgrade causes nodes to reject blocks verified with nodes using the older version of software. To prevent this, nodes must simaltanously upgrade to the new software version to continue to accept and generate blocks on new chain. (New chain incompatible with old chain).
      - Hard forks are generally used when there is consensus about software changes being made.
      - If there's no consensus about the change, blockchain may fork. Forking blockchain can reduce security of system - each branch of fork will have smaller community working to support security of system.
    - Soft Forks
      - Blocks verified by nodes running older software are compatiable with nodes running latest version of software. Both rulesets exist on the same chain.
      - The change is backward compatible with old chain.
      - New block rules are more strict and follow subset of old block rules. Co-exist on same chain.
      - Miners can choose to adopt the change, and if 51% of network adopts new rules, old rules will no longer be accepted and the changes will be adopted by the network.
      - Used for smaller network changes

### Resources

[Light client protocol - Ethereum Docs](https://github.com/ethereum/wiki/wiki/Light-client-protocol)
[A Short Guide to Bitcoin Forks](https://www.coindesk.com/short-guide-bitcoin-forks-explained/)
